<div id='app'></div>
<script>

function h(tag, props, children) {
    return {
      tag,
      props,
      children,
    };
  }

  function createText(text) {
    return new Text(text);
  }
  
  function remove(el, parent) {
    parent.remove(el);
  }
  
  function createElement(type) {
    return document.createElement(type);
  }
  
  function setText(el, text) {
    el.textContent = text;
  }
  
  function insert(el, parent) {
      console.log(parent,el);
    parent.append(el);
  }
  
  function patchProp(el, key, prevValue, nextValue) {
    // onClick
    // 1. 如果前面2个值是 on 的话
    // 2. 就认为它是一个事件
    // 3. on 后面的就是对应的事件名
    if (key.startsWith("on")) {
      const eventName = key.slice(2).toLocaleLowerCase();
      el.addEventListener(eventName, nextValue);
    } else {
      if (nextValue === null) {
        el.removeAttribute(key, nextValue);
      } else {
        el.setAttribute(key, nextValue);
      }
    }
  }
  
  function patch(v1, v2) {
    // 1. 如果 tag 都不一样的话，直接替换
    // 2. 如果 tag 一样的话
    //    1. 要检测 props 哪些有变化
    //    2. 要检测 children  -》 特别复杂的
    const { props: oldProps, children: oldChildren = [] } = v1;
    const { props: newProps, children: newChildren = [] } = v2;
    if (v1.tag !== v2.tag) {
      v1.replaceWith(createElement(v2.tag));
    } else {
      const el = (v2.el = v1.el);
      // 对比 props
      // 1. 新的节点不等于老节点的值 -> 直接赋值
      // 2. 把老节点里面新节点不存在的 key 都删除掉
      if (newProps) {
        Object.keys(newProps).forEach((key) => {
          if (newProps[key] !== oldProps[key]) {
            patchProp(el, key, oldProps[key], newProps[key]);
          }
        });
  
        // 遍历老节点 -》 新节点里面没有的话，那么都删除掉
        Object.keys(oldProps).forEach((key) => {
          if (!newProps[key]) {
            patchProp(el, key, oldProps[key], null);
          }
        });
      }
      // 对比 children
  
      // newChildren -> string
      // oldChildren -> string   oldChildren -> array
  
      // newChildren -> array
      // oldChildren -> string   oldChildren -> array
      if (typeof newChildren === "string") {
        if (typeof oldChildren === "string") {
          if (newChildren !== oldChildren) {
            setText(el, newChildren);
          }
        } else if (Array.isArray(oldChildren)) {
          // 把之前的元素都替换掉
          v1.el.textContent = newChildren;
        }
      } else if (Array.isArray(newChildren)) {
        if (typeof oldChildren === "string") {
          // 清空之前的数据
          el.innerHTML = "";
          // 把所有的 children mount 出来
          newChildren.forEach((vnode) => {
            mount(vnode, el);
          });
        } else if (Array.isArray(oldChildren)) {
          // a, b, c, d, e -> new
          // a1,b1,c1,d1 -> old
          // 如果 new 的多的话，那么创建一个新的
  
          // a, b, c -> new
          // a1,b1,c1,d1 -> old
          // 如果 old 的多的话，那么把多的都删除掉
          const length = Math.min(newChildren.length, oldChildren.length);
          for (let i = 0; i < length; i++) {
            const oldVnode = oldChildren[i];
            const newVnode = newChildren[i];
            // 可以十分复杂
            patch(oldVnode, newVnode);
          }
  
          if (oldChildren.length > newChildren.length) {
            // 说明老的节点多
            // 都删除掉
            for (let i = length; i < oldChildren.length; i++) {
              remove(oldChildren[i], el);
            }
          } else if (newChildren.length > oldChildren.length) {
            // 说明 new 的节点多
            // 那么需要创建对应的节点
            for (let i = length; i < newChildren.length; i++) {
              mount(newChildren[i], el);
            }
          }
        }
      }
    }
  }
  
  function mount(vnode, container) {
    // 渲染成真实的 dom 节点
    const el = (vnode.el = createElement(vnode.tag));
  
    // 处理 props
    if (vnode.props) {
      for (const key in vnode.props) {
        const val = vnode.props[key];
        patchProp(vnode.el, key, null, val);
      }
    }
  
    // 要处理 children
    if (Array.isArray(vnode.children)) {
      vnode.children.forEach((v) => {
        mount(v, el);
      });
    } else {
      insert(createText(vnode.children), el);
    }
    
    // 插入到视图内
    insert(el, container);
  }
  
// reactivity part
// 1. 收集依赖
// 2. 触发依赖
let currentEffect;
class Dep {
  constructor() {
    // 收集依赖的容器
    this.effects = new Set();
  }
  // get value() {
  //   this.depend();
  //   return this.val;
  // }

  // set value(newVal) {
  //   this.val = newVal;
  //   this.notice();
  // }
  depend() {
    if (currentEffect) {
      this.effects.add(currentEffect);
    }
  }

  notice() {
    for (const effect of this.effects) {
      effect();
    }
  }
}

function watchEffect (effect)  {
  currentEffect = effect;
  effect();
  currentEffect = null;
};

// export function ref (rawVal) {
//     return new Dep(rawVal)
// }

const targetMap = new WeakMap();
function getDep (target, key){
    // 去找到当前 key 对应的 dep
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      depsMap = new Map();
      targetMap.set(target, depsMap);
    }

    let dep = depsMap.get(key);
    if (!dep) {
      dep = new Dep();
      depsMap.set(key, dep);
    }

    return dep;
  }
 function reactive(raw) {
  // 对象
  // 如果对象的每个 key 当做之前的 dep 的话，那么一个 key 就应该有一个 dep
  // 每一个 key 的 dep 应该存储在哪里
  // 设置的时候，是不是需要调用到 dep 的 notice 或者是 depend
  // 之前我们学过用 object.definePropriety
  // Proxy

  // 多个对象
  // 当前这个对象
  // 基于它的key 来找对应的 dep 啊

  return new Proxy(raw, {
    get(target, key) {
      // 去找到当前 key 对应的 dep
      const dep = getDep(target, key);
      // 依赖收集
      dep.depend();

      // return target[key]
      return Reflect.get(target, key);
    },
    set(target, key, val) {
      // 还是需要找到 dep
      const dep = getDep(target, key);
      const result = Reflect.set(target, key, val);
      dep.notice();
      return result;
    },
  });
}

// 考虑到最终的框架API 定义一个组件
const App={
    render(content) {
          return h("div", null, [
            h("div", null, String(content.state.message)),
            h(
              "button",
              {
                onClick: content.click,
              },
              "click"
            ),
          ]);
        },
    
    setup() {
          const state = reactive({
            message: "Hello Vue 3!!",
          });

          const click = () => {
            state.message = state.message.split("").reverse().join("");
          };
          return { state, click };
        },


}

const Vue={
    createApp(config){
        return {
            mount:function(container){
            
                let setupResult= config.setup();
                let render=config.render(setupResult);
                let el= document.querySelector(container);
                let isMounted=false;
                let prevVdom;
                watchEffect(()=>{
                    if(!isMounted){
                        prevVdom=config.render(setupResult);
                        mount(prevVdom,el);
                        isMounted=true;
                    }else{
                        const newVdom=config.render(setupResult);
                        patch(prevVdom,newVdom);
                        prevVdom=newVdom;
                    }
                });

            }
        }
    }
}
function mountApp(component,container){
    let isMounted=false;
    let prevVdom;
    watchEffect(()=>{
        if(!isMounted){
            prevVdom=component.render();
            mount(prevVdom,container);
            isMounted=true;
        }else{
            const newVdom=component.render();
            patch(prevVdom,newVdom);
            prevVdom=newVdom;
        }
    });
}


// mountApp(App,document.getElementById('app'));
const { createApp} =Vue;
createApp(App).mount('#app');
</script>